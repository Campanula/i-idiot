#ifndef PARSE_H
#define PARSE_H
/**
 * 算术表达式的构建，形成一个二叉树结构。所以其中的主要结构是二元操作符结构（也可能存在三元操作符）
 * 而叶子节点是一元操作符，或者是数字。
 * 
 * +     加号，与输入一致，生成 Bin-Add 节点
 * -     减号，与输入一致，生成 Bin-Sub 节点
 * *     乘号，与输入一致，生成 Bin-Mult 节点
 * div/  除号，与输入一致，生成 Bin-Div 节点
 * -     负号，与输入一致，生成 Un-Minus 节点
 * n     数字，与输入不一致，实际输入为一串任意有效浮点数字，生成 Val-Value 节点
 * (|)   括号，与输入一致，本身不参与到表达式中，只用作上下文，指示构建优先级更高的作为整体的子表达式
 *
 * */

/**
 * 语句由符号和算术表达式组成。
 * 常量，变量作为叶子节点，其中变量既可以作为左值也可以作为右值，视上下文 token 而定,
 * 作为左值，需要参与到 Assign 的二元操作中，作为右值，提供数字。
 *
 * 符号并不会一开始就参与到语句树的构建中，程序会通过扫描输入字符，先将新出现的符号构建好，添加到 symbol names
 * 然后根据 token 规则构建语句树，所以符号节点本身的构建是先于语句树的构建的。
 * 
 * v     变量，与输入不一致，实际输入为一串任意有效的符号名，添加到 symbol names 中，最后参与到语句树的构建中。
 *       可以是作为左值的 Bin-Assign 左树叶子节点；也可以是作为右值的 Var-Var 叶子节点。
 *
 * c     常量，与输入不一致，实际输入在预定义的一系列固定值范围内，位于 symbol names 中, 最后作为叶子节点 Var-Var 。
 *
 * m     函数，与输入不一致，实际输入在预定义的一系列固定值范围内, 位于 symbol names 中，最后作为 Bin-Math 左树叶子节点。
 *
 * l     let关键字，与输入不一致，实际输入为固定的 "let"，位于 symbol names 中，符号本身不参与到语句中，只用作上下文
 *       指示构建 Bin-Assign 节点，节点左子树是 Var。
 *
 * */


enum tokens {
    NUMBER = 'n',  // 数字
    CONST = 'c',   // 常量
    MATH = 'm',    // 函数
    VAR = 'v',     // 变量名
    LET = 'l',     // 关键字
};

void error(const char * fmt, ...);

#endif

